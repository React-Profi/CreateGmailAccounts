"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const puppeteer_extra_1 = __importDefault(require("puppeteer-extra"));
const constants_1 = require("./constants");
const plugin_1 = __importDefault(require("./plugin"));
const schemas_1 = require("./schemas");
jest.setTimeout(50000);
async function isStealth(browser) {
    if (!browser) {
        browser = await puppeteer_extra_1.default.launch({
            headless: true,
            args: ["--proxy-server=" + constants_1.TESTING_PROXY_SERVER]
        });
    }
    const page = await browser.newPage();
    await page.goto("https://whoer.net");
    const stealth = await Promise.race([
        page
            .waitForSelector("#main > section.section.section_ip-check.section_white > div > div > div > div.tab.tab_lite > div.row > div:nth-child(2) > div:nth-child(1) > div > div > div.card__data > div:nth-child(1) > div.card__col.card__col_value.matched.highlighted_red")
            .then(() => false),
        page
            .waitForSelector("#main > section.section.section_ip-check.section_white > div > div > div > div.tab.tab_lite > div.row > div:nth-child(2) > div:nth-child(1) > div > div > div.card__data > div:nth-child(1) > div.card__col.card__col_value.matched.highlighted_green")
            .then(() => true)
    ]);
    await browser.close();
    return stealth;
}
it("isn't stealth when not using the timezone plugin", async () => {
    await expect(isStealth()).resolves.toBe(false);
});
let plugin;
plugin = plugin_1.default();
puppeteer_extra_1.default.use(plugin);
it("emulates the right timezone for the current IP", async () => {
    await expect(isStealth()).resolves.toBe(true);
});
it("emulates the right timezone for multiple browsers concurrently", async () => {
    const proxyBrowser = await puppeteer_extra_1.default.launch({
        headless: true,
        args: ["--proxy-server=" + constants_1.TESTING_PROXY_SERVER]
    });
    const normalBrowser = await puppeteer_extra_1.default.launch({
        headless: true
    });
    // the second browser opening should have overidden the timezone context of the first
    await expect(isStealth(proxyBrowser)).resolves.toBe(true);
    await Promise.all([proxyBrowser.close(), normalBrowser.close()]);
});
async function getBrowserId(browser) {
    const browserInfo = schemas_1.TargetInfoSchema.parse(await (await browser.target().createCDPSession()).send("Target.getTargetInfo"));
    return browserInfo.targetInfo.targetId;
}
it("does not keep the cache entry once the browser is closed", async () => {
    const browser = await puppeteer_extra_1.default.launch({
        headless: true
    });
    const browserId = await getBrowserId(browser);
    expect(plugin.ctx.get(browserId)).toBeDefined();
    await browser.close();
    expect(plugin.ctx.get(browserId)).toBeUndefined();
});
//# sourceMappingURL=plugin.spec.js.map